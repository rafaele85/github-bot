# возможные варианты ошибок
enum ErrorType {
  ValidationError
  LimitRequiredError
  BadRequestError
  UnauthorizedError
  ForbiddenError
  NotFoundError
  UnprocessableEntityError
  TooManyRequestsError
  ClientClosedRequestError
  TooManyInvitesError
  TooManyInvitesPerContactError
  UserWithSameEmailExists
  UserWithSamePhoneExists
  MembersLimitExceded
  BAD_CREDENTIALS
  USER_INACTIVE
  TOO_MANY_ATTEMPTS
}

# тип файла
enum FileType {
  # документ
  DOCUMENT

  # изображение
  IMAGE
}

# локаль
enum Locale {
  # английская
  EN

  # русская
  RU
}

# статус вашего участия в чате
enum ChatState {
  # активен
  ACTIVE

  # создатель завершил чат
  CLOSED

  # вы покинули чат
  LEAVED

  # вы удалены из чата
  DELETED
}

# уровень назойливости событий чата
enum ChatNotificationState {
  # не создают звуков в клиенте, не создают звуков в пуш уведомлении
  MUTE

  # не создают звуков в клиенте, не создают пуш уведомлений
  OFF

  # звук в клиенту включен, приходят пуши со звуком
  ON
}

# текущий шаг регистрации
enum RegistrationStep {
  # ожидается ввод регистрационнаго кода
  VOUCHER_FILLING

  # ожидает заполнения профиля
  PROFILE_FILLING
}

# статус подзадачи
enum TodoState {
  # подзадача активна
  ACTIVE

  # подзадача закрыта
  CLOSED
}

type Query {
  # # установка токена
  # действует для внутренних полей,
  # с сестринскими полями поведение не определено
  # ## Доступ
  # любой анонимный пользователь
  withToken(
    # токен аутентификации
    token: String!
  ): Query!

  # # Чат по идентификатору
  # ## Доступ
  # пользователь является участником чата
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *404 Not Found*, объект не найден
  chat(id: ID!): IChat!

  # # Список чатов
  # ## Доступ
  # пользователь является участником чата
  # если это личка - в нее были созданы сообщения
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  chats(
    filter: ChatsFilterInput
    after: String
    first: Int
    before: String
    last: Int
  ): IChatConnection!

  # # Колонка по идентификатору
  # ## Доступ
  # Пользователь - создатель группы
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *404 Not Found*, объект не найден
  group(id: ID!): Group!

  # # Список колонок
  # ## Доступ
  # Пользователь - создатель группы
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  groups: GroupConnection!

  # # Список задач
  # ## Доступ
  # задача связана с чатом, к которому пользователь имеет доступ
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  issues(
    filter: IssuesFilterInput
    after: String
    first: Int
    before: String
    last: Int
  ): IssueConnection!

  # # Задача по идентификатору
  # ## Доступ
  # задача связана с чатом, к которому пользователь имеет доступ
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *404 Not Found*, объект не найден
  issue(id: ID!): Issue!
  searchIssue(q: String!): IssueSearchConnection!

  # # Сообщение по идентификатору
  # ## Доступ
  # пользователь был активным участником чата на момент создания сообщения
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *404 Not Found*, объект не найден
  message(id: ID!): IMessage!

  # # Полнотекстовый поиск по тексту сообщений
  # ## Доступ
  # пользователь был активным участником чата на момент создания сообщения
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  searchMessages(
    after: String
    first: Int! = 20

    # Текст поиска
    query: String!
    filter: SearchMessageFilter
  ): SearchMessagesConnection!

  # # Избранные сообщения
  # Сообщения выводятся по убыванию времени добавления в избранные
  # ## Доступ
  # пользователь добавил сообщение в избанные
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  favoriteMessages(
    after: String
    first: Int
    before: String
    last: Int
  ): IMessageConnection!

  # # Конфигурация сервера
  settings: Settings!

  # # Время сервера
  # Используется для синхронизации времени клиента и сервера.
  # Для синхронизации рекомендуется использовать алгоритм компенсации, аналогичный SNTP.
  # [пример использования, rest заменить на graphql](
  #     https://github.com/enmasseio/timesync/blob/master/examples/advanced/express/index.html
  # )
  timesync: DateTime!

  # # Параметры пользователя
  userSettings: JSON

  # Локаль текущего соединения
  locale: Locale!

  # # Тег по идентификатору
  # ## Доступ
  # Пользователь - создатель группы
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *404 Not Found*, объект не найден
  tag(id: ID!): Tag!

  # # Список тегов
  # ## Доступ
  # Пользователь - создатель группы
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  tags: TagConnection!

  # # Поиск пользователей
  # Поиск производится по полям last_name, first_name, job_title, city, email
  # по полному соответствию.
  # По email также происходит поиск по триграммам, а также по подстроке.
  # ## Доступ
  # все пользователи доступны
  search(
    # исключить пользователей по id
    exclude: [ID!]

    # количество пользователей в поисковой выдаче
    first: Int

    # строка поиска
    q: String!
  ): [ActiveUser!]!

  # # Текущий пользователь
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован
  me: MyUser!

  # # Пользователь по идентификатору
  # ## Доступ
  # текущий пользователь и искомый имеют общий чат/задачу/напоминание
  # либо явно добавлены с использованием addContact
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *404 Not Found*, объект не найден
  user(id: ID!): User!

  # # Получение пользователя по номеру телефона
  # ## Доступ
  # любой активный пользователь
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  user_by_phone(phone: PhoneNumber!): User

  # # Напоминание по идентификатору
  # ## Доступ
  # пользователь является получателем напоминания
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *404 Not Found*, объект не найден
  reminder(id: ID!): Reminder!

  # # Список напоминаний
  # ## Доступ
  # пользователь является получателем напоминания
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  reminders(
    filter: ReminderFilterInput
    after: String
    first: Int
    before: String
    last: Int
  ): ReminderConnection!

  # # Список пользователей добавленных в контакты
  # ## Доступ
  # пользователи явно добавлены с использованием мутации addContact
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  contactUsers(
    first: Int
    after: String
    last: Int
    before: String
  ): ContactUsersConnection!

  # # Список пользователей
  # ## Доступ
  # текущий пользователь и искомый имеют общий чат/задачу/напоминание
  # либо явно добавлены с использованием addContact
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  users: RootUserConnection!

  # # Перечень пользователей, имеющих отзыв
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  usersWithReview(first: Int!, after: String): UsersWithReviewConnection!

  # # Рекомендация по идентификатору
  # ## Доступ
  # любой аутентифицированный пользователь
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *404 Not Found*, объект не найден
  review(id: ID!): Review!
}

type Mutation {
  # # установка токена
  # действует для последующих мутаций,
  # при использовании ws, для всех последующих операций
  # ## Доступ
  # любой пользователь
  setToken(
    # токен аутентификации
    token: String!
  ): Boolean

  # # обновление токена аутентификации
  # Время жизни токена ограничено, время жизни можно получить при создании токена
  # ## Доступ
  # любой аутентифицированный пользователь может обменять старый токен
  # на новый с продленным временем действия,
  # причем старый токен становится не действительным
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  refreshToken: AuthToken!

  # # токен аутентификации по одноразовому паролю
  # Обмен одноразового логина, полученного при вызове мутации makeOTP,
  # и одноразового пароля, высланного в смс на токен аутентификации
  # ## Доступ
  # любой неаутентифицированный пользователь
  # ## Ошибки
  # - *401 Unauthorized*, одноразовый логин не найден
  # - *429 TooManyRequests*, последняя попытка использована, следует запросить новый код
  otpToToken(
    # одноразовый логин
    login: String!

    # одноразовый пароль
    password: String!
  ): OTPToTokenResult!

  # # Запрос одноразового пароля
  # Для того, чтобы аутентифицироваться на сервисе, необходимо
  # запросить одноразовый пароль. Одноразовый пароль высылается на телефон,
  # указанный в качестве аргумента. Если номер не найден в системе,
  # создается новый пользователь. Одноразовый логин и код ожидаются для
  # поля otpToToken
  # ## Доступ
  # любой неаутентифицированный пользователь
  # ## Ошибки
  # - *429 TooManyRequests*, если на данный номер повторно запрошен одноразовый пароль
  #   до истечения времени из поля nextBackoffTime. Одно из полей ошибки содержит время,
  #   оставшееся до разрешения следующего запроса.
  makeOTP(
    # Мобильный телефон
    phone: PhoneNumber!
  ): MakeOTPResult!

  # # Запрос на изменение телефонного номера
  # На указанный номер телефона отправляется код подтвержения.
  # Если вновь указанный номер телефона уже привязан к другому пользователю,
  # другой пользователь переводится в статус DISABLED, его номер телефона заменяется
  # на null. Возвращает время, до которого сервис не принимает от данного пользователя
  # данных запросов.
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *429 TooManyRequests*, если данным пользователем повторно запрошен код
  #   до истечения времени из поля nextBackoffTime. Одно из полей ошибки содержит время,
  #   оставшееся до разрешения следующего запроса.
  requestPhoneUpdate(
    # Новое значение телефона пользователя
    phone: PhoneNumber!
  ): DateTime

  # # подтверждение телефона
  # Подтверждение телефона происходит путем передачи в качестве аргумента кода,
  # высланного в смс при запросе мутации requestPhoneUpdate.
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*, если код не корректен.
  # - *429 TooManyRequests*, если данным пользователем повторно запрошен код
  #   до истечения времени, возвращенного прошлым заросом. Одно из полей ошибки содержит время,
  #   оставшееся до разрешения следующего запроса.
  verifyPhone(
    # Код подтверждения
    code: String!
  ): PhoneNumber!

  # # Погашение регистрационного промокода
  # Если включена регистрация по промокодам, то перед
  # заполнением профиля, необходимо указать промокод
  # ## Возвращает
  # новое состояние регистрации
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован
  #   или не находится в состоянии 'VAUCHER_WAITING'
  # - *403 Forbidden*, если код не корректен
  setVoucher(
    # Промокод
    voucher: String!
  ): RegistrationStep!

  # # создание приватного чата (переговорка)
  # Приватный чат создается для текущего пользователя и указанного пользователя (user_id)
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*, приватный чат между пользователями уже существует
  newPrivateChat(
    # свойства вновь создаваемого чата
    input: NewPrivateChatInput!

    # идентификатор пользователя
    user_id: ID!
  ): PrivateChat!

  # # создание чата
  # участниками вновь созданного чата являются текущий пользователь и
  # указанные пользователи (user_ids)
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*, id создаваемого чата уже существует
  newChat(
    # поля вновь создаваемого чата
    input: NewChatInput!

    # поля вновь создаваемой задачи, связанной с чатом
    issue_input: NewIssueInput

    # идентификаторы пользователей
    user_ids: [ID!]! = []
  ): Chat!

  # # Обновление чата
  # ## Доступ
  # пользователь должен быть участником чата
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 ForbiddenError*:
  #     - попытка обновить собственные поля приватного чата
  #     - статус участника текущего пользователя не позволяет обновить указанные поля
  # - *404 NotFound*, чат не найден, либо текущий пользователь не участник чата
  updateChat(
    # идентификатор чата
    id: ID!

    # значения полей чата
    input: UpdateChatInput!
  ): IChat!

  # # Удаление чата
  # ## Доступ
  # участник должен быть создателем чата, не важно в каком статусе
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 ForbiddenError*:
  #     - пользователь не является создателем чата
  #     - попытка удалить личку
  # - *404 NotFound*, чат не найден, либо текущий пользователь не участник чата
  deleteChat(
    # идентификатор чата
    id: ID!
  ): ID!

  # # Установка нового "создателя"
  # ## Доступ
  # текущий пользователь должен быть в роле "создателя"
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 ForbiddenError*:
  #     - попытка изменить создателя в приватном чата
  #     - чат закрыт
  #     - текущий пользователь не создатель
  #     - новый пользователь не активный участник
  # - *404 NotFound*:
  #     - чат не найден
  #     - текущий пользователь не участник чата
  #     - не найден участник, которому передаются права
  changeChatCreator(
    # идентификатор чата
    chat_id: ID!

    # идентификатор пользователя, которому передается роль создателя
    user_id: ID!
  ): Null

  # # Создание отметки о прочитанных сообщениях
  # данным методом клиент уведомляет сервис, что пользователь прочел
  # указанный чат (chat_id) до указанного сообщения (bookmark_message_id)
  # ## Доступ
  # пользователь должен быть активным участником чата
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *404 NotFound*:
  #     - чат не найден
  #     - текущий пользователь не участник чата
  #     - сообщение не найдено
  # - *422 ForbiddenError*:
  #     - попытка переустановить отметку на более раннее сообщение
  #     - попытка переустановить отметку на то-же сообщение
  moveBookmark(
    # букмарк последнего прочитанного сообщения (IChatMessageEdge.bookmark)
    bookmark: Bookmark!

    # идентификатор чата
    chat_id: ID!
  ): CheckStatus!

  # # Закрытие чата
  # ## Доступ
  # Текущий пользователь должен быть создателем чата
  # ## Ошибки
  # - *401 Unauthorized*: пользователь не аутентифицирован или не активен
  # - *404 NotFound*:
  #     - чат не найден
  #     - текущий пользователь не участник чата
  # - *422 ForbiddenError*:
  #     - пользователь не является создателем чата
  #     - попытка закрыть уже закрытый чат
  #     - попытка закрыть личный чат
  closeChat(chat_id: ID!): Null

  # # Возобновление чата
  # ## Доступ
  # Текущий пользователь должен быть создателем чата
  # ## Ошибки
  # - *401 Unauthorized*: пользователь не аутентифицирован или не активен
  # - *404 NotFound*:
  #     - чат не найден
  #     - текущий пользователь не участник чата
  # - *422 ForbiddenError*:
  #     - пользователь не является создателем чата
  #     - попытка возобновить незакрытый чат
  resumeChat(chat_id: ID!): Null

  # # Выход из чата
  # ## Доступ
  # Текущий пользователь должен быть обычным участником чата (не создатель)
  # ## Ошибки
  # - *401 Unauthorized*: пользователь не аутентифицирован или не активен
  # - *404 NotFound*:
  #     - чат не найден
  #     - текущий пользователь не участник чата
  # - *422 ForbiddenError*:
  #     - пользователь является создателем чата
  #     - чат закрыт
  #     - попытка выйти из уже покинутого чата
  #     - личный чат
  leaveFromChat(chat_id: ID!): Null

  # # Возвращение в чат
  # ## Доступ
  # Текущий пользователь должен быть обычным участником чата (не создатель)
  # ## Ошибки
  # - *401 Unauthorized*: пользователь не аутентифицирован или не активен
  # - *404 NotFound*:
  #     - чат не найден
  #     - текущий пользователь не участник чата
  # - *422 ForbiddenError*:
  #     - пользователь является создателем чата
  #     - чат закрыт
  #     - попытка вернуться в чат, в котором вы уже состоите
  #     - личный чат
  returnToChat(chat_id: ID!): Null

  # # Добавление пользователя в чат
  # ## Доступ
  # Текущий пользователь должен быть создателем чата
  # ## Ошибки
  # - *401 Unauthorized*: пользователь не аутентифицирован или не активен
  # - *404 NotFound*:
  #     - чат не найден
  #     - текущий пользователь не участник чата
  # - *422 ForbiddenError*:
  #     - пользователь не является создателем чата
  #     - попытка добавить пользователя, который уже существует
  #     - личный чат
  addUserToChat(chat_id: ID!, user_id: ID!): ChatMember!

  # # Исключение пользователя из чата
  # ## Доступ
  # Текущий пользователь должен быть создателем чата
  # ## Ошибки
  # - *401 Unauthorized*: пользователь не аутентифицирован или не активен
  # - *404 NotFound*:
  #     - чат не найден
  #     - текущий пользователь не участник чата
  #     - исключаемый пользователь не найден
  # - *422 ForbiddenError*:
  #     - пользователь не является создателем чата
  #     - попытка добавить пользователя, который уже существует
  removeUserFromChat(chat_id: ID!, user_id: ID!): ChatMember!

  # # Сохранение черновика сообщения
  # ## Доступ
  # пользователь должен быть активным участником чата
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *404 NotFound*:
  #     - чат не найден, либо текущий пользователь не участник чата
  # - *422 UnprocessableEntity*:
  #     - черновик слишком большой (более 50000)
  setDraft(chat_id: ID!, draft: String!): Null

  # # Подписка запроса на загрузку изображения чата
  # ## Доступ
  # Любой активный участник чата
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или находится в неверном статусе
  # - *403 Forbidden*:
  #     - попытка загрузить изображение в несуществующий чат,
  #       либо пользователь не является активным участником чата
  presignChatImage(input: PresignChatImageInput!): PresignedRequest!

  # # Подписка запроса на загрузку аватара пользователя
  # ## Доступ
  # Любой активный пользователь
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или находится в неверном статусе
  presignUserImage(input: PresignUserImageInput!): PresignedRequest!

  # # Подписка файла для сообщения
  # ## Доступ
  # Любой активный участник чата
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или находится в неверном статусе
  # - *403 Forbidden*:
  #     - попытка прикрепить файл к несуществующему чату,
  #       либо пользователь не является активным участником чата
  presignMessageFile(input: PresignMessageFileInput!): PresignedRequest!

  # # Удаление файла
  # ## Доступ
  # Для удаления доступны только файлы прикрепленные к чату (AttachedFile)
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *404 NotFound*: файл не найден
  deleteFile(id: ID!): ID!

  # # Создание колонок для задач
  # ## Доступ
  # Любой пользователь может создавать колонки
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  newGroup(
    # поля создаваемой группы
    input: NewGroupInput!
  ): Group!

  # # Обновление свойств колонки задач
  # ## Доступ
  # Пользователь может обновить любую созданную им колонку
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  updateGroup(
    # идентификатор обновляемой колонки
    id: ID!

    # поля создаваемой группы
    input: UpdateGroupInput!
  ): Group!

  # # Удаление колонки задач
  # ## Доступ
  # Пользователь может удалить пустую колонку
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*, попытка удалить дефолтную колонку
  # - *404 Not Found*, колонка не найдена
  deleteGroup(
    # идентификатор группы
    id: ID!
  ): ID!

  # # Скрытие дефолтной колонки
  # ## Доступ
  # У всех пользователей есть дефолтная колонка и они могут ее скрыть
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  hideDefaultGroup: Group!

  # # Обновление задачи
  # Задача связывается с уже созданным чатом (chat_id).
  # ## Доступ
  # Пользователь должен быть участником чата, связанного с задачей
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*, не создатель пытается установить исполнителя
  # - *404 Not Found*:
  #     - задача не найдена
  #     - пользователь не является участником связанного чата
  updateIssue(
    # идентификатор задачи
    id: ID!

    # обновляемые поля задачи
    input: UpdateIssueInput!
  ): Issue!

  # # создание сообщений
  # Доступны к созданию текстовые и файловые сообщения.
  # Для создания файловых сообщений, файлы необходимо предварительно загрузить
  # в методе uploadFiles.
  # # Доступ
  # Пользователь должен быть активным участником чата, в котором
  # создаются файлы.
  # ## Ошибки
  # - *400 BadRequest*, передан пустой список сообщений
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*:
  #     - создается текстовое сообщение без текста и цитаты
  #     - пользователь не является активным участником чата
  # - *404 Not Found*:
  #     - чат не найден
  #     - файл не найден
  #     - цитируемое сообщение не найдено
  # - *429 TooManyRequests*, возвращается в случае попытки отправки более
  #   30 сообщений в секунду.
  newMessages(
    # идентификатор чата
    chat_id: ID!

    # поля создаваемых сообщений
    input: [NewMessageInput!]!
  ): [IMessage!]! @deprecated(reason: "используйте Mutation.newMessages2")

  # # создание сообщений
  # Доступны к созданию текстовые и файловые сообщения.
  # Для создания файловых сообщений, файлы необходимо предварительно загрузить
  # в методе uploadFiles.
  # # Доступ
  # Пользователь должен быть активным участником чата, в котором
  # создаются файлы.
  # ## Ошибки
  # - *400 BadRequest*, передан пустой список сообщений
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*:
  #     - создается текстовое сообщение без текста и цитаты
  #     - пользователь не является активным участником чата
  # - *404 Not Found*:
  #     - чат не найден
  #     - файл не найден
  #     - цитируемое сообщение не найдено
  newMessages2(
    # идентификатор чата
    chat_id: ID!

    # поля создаваемых сообщений
    input: [NewMessageInput!]!
  ): IChatMessageConnection!

  # # пересылка сообщений
  # Пользователь может переслать только те сообщения,
  # к которым он имеет доступ
  # Максимально пользователь может переслать `settings.maxForwardMessages` сообщений
  # в `settings.maxForwardChats` чатов
  forwardMessages(
    # идентификаторы сообщений
    message_ids: [ID!]!

    # идентификаторы чатов-получателей
    to_chat_ids: [ID!]!
  ): ChatForwardMessageConnection!

  # # Обновление текстового сообщения
  # Обновление сообщение доступно в течение ограниченного времени.
  # Данное время в можно получить из запроса query { settings { messageEditTimeDelta } }
  # # Доступ
  # Пользователь должен быть отправителем сообщения и активным участником чата
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*:
  #     - вы не создатель сообщения
  #     - пользователь не является активным участником чата
  #     - время обновления сообщения превышено
  # - *404 Not Found*:
  #     - сообщение не найдено
  updateRegularMessage(
    # поля обновляемого сообщения
    input: UpdateMessageInput!

    # идентификатор сообщения
    message_id: ID!
  ): RegularMessage!

  # # Удаление сообщений
  # Удаление сообщений доступно в течение ограниченного времени после создания сообщения.
  # Данное время в можно получить из запроса query { settings { messageDeleteTimeDelta } }
  # К удалению доступно ограниченное количество сообщений.
  # Данное количество можно получить из запроса query { settings { maxDeleteMessagesCount } }
  # Если одно из сообщений не найдено, оно будет молча пропущено, остальные будут удалены,
  # клиенту не будет возвращена ошибка.
  # # Доступ
  # Пользователь должен быть отправителем сообщения и активным участником чата
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*:
  #     - вы не создатель сообщения
  #     - пользователь не является активным участником чата
  #     - время удаления сообщения превышено
  deleteMessages(
    # идентификатор чата, откуда удаляются сообщения
    chat_id: ID!

    # идентификатор удаляемых сообщений
    message_ids: [ID!]!
  ): [ID]!

  # # Изменение отметки "избранное" для сообщения
  # Пользователь может добавлять и удалять сообщения в "избранное"
  # # Доступ
  # Пользователь должен состоять в соответсвующем чате в момент создания сообщения.
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *404 Not Found*, сообщение не найдено
  setMessageFavorite(
    # флаг избранного
    favorite: Boolean!

    # идентификатор сообщения
    message_id: ID!
  ): Boolean

  # # Установка локали
  # Локаль используется для формирования имени пользователя и сервисных сообщений.
  # ## Доступ
  # Пользователь активен
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  setLocale(
    # новая локаль клиента
    locale: Locale!
  ): Null

  # # Оповещение "печатает"
  # Клиент сообщает сервису, что пользователь набирает текст.
  # При наборе текста клиент должен вызывать данный метод каждые n секунд
  # до тех пор, пока пользователь не завершил набор. n следует получить из
  # { settings { typingTimeout } }.
  # ## Доступ
  # Пользователь должен быть активным участником чата.
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*: пользователь не является активным участником чата
  typing(
    # идентификатор чата
    chat_id: ID!
  ): Null

  # # Установить статус клиента
  # Явное оповещение сервиса о статусе клиента. Если пользователь не находится
  # в статусе онлайн ни с одного клиента, считается, что он офлайн.
  # По-умолчанию клиент становится онлайн при создании вебсокет канала с
  # сервисом и офлайн при разрыве. Явно указать статус клиента можно с использованием
  # данного метода.
  # ## Доступ
  # Пользователь активен, клиент для вызова метода использует вебсокет.
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *422 Unprocessable entity*, метод вызван не используя вебсокет в качестве транспорта
  setClientStatus(
    # статус клиента
    online: Boolean!
  ): Null

  # # Установить настройки пользователя
  # Данные настройки используются исключительно клиентами,
  # никак не влияют на поведение сервера.
  # ## Доступ
  # Пользователь аутентифицирован и активен
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *422 Unprocessable entity*, переданный json > 32000 символов
  setUserSettings(
    # настройки пользователя,
    # допускается любой валидный json, ограничение в 32000 символов
    data: JSON!
  ): Null

  # # Создание тегов
  # ## Доступ
  # Любой пользователь может создавать теги
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  newTag(
    # поля создаваемой группы
    input: NewTagInput!
  ): Tag!

  # # Обновление свойств тегов
  # ## Доступ
  # Пользователь может обновить любую созданнуй им тег
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  updateTag(
    # идентификатор обновляемого тега
    id: ID!

    # поля создаваемой группы
    input: UpdateTagInput!
  ): Tag!

  # # Удаление тега
  # ## Доступ
  # Пользователь может удалить любой свой тег
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Not Found*, тег не найден
  deleteTag(
    # идентификатор группы
    id: ID!
  ): ID!

  # # Установка тегов задачи
  # При установке нового списка тегов, прежний сбрасывается
  # ## Доступ
  # Пользователь может прикреплять к задаче только собственные теги
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Not Found*, тег не найден
  setIssueTags(
    # идентификатор задачи
    issue_id: ID!

    # идентификаторы тегов
    tag_ids: [ID!]!
  ): Issue!

  # # Обновление дела
  # Дело должно быть привязано к существующей задаче
  # ## Доступ
  # Пользователь должен быть участником чата, связанного с делом
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*:
  #     - пользователь не является активным участником
  #     соответствующего чата
  #     - идентификатор уже существует в системе
  # - *404 Not Found*: соответствующий чат не найден в систем
  #   либо текущий пользователь не является участником чата
  newTodo(input: NewTodoInput!): Todo!

  # # Удаление дела
  # ## Доступ
  # Пользователь должен быть участником чата, связанного с задачей
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *404 Not Found*:
  #     - задача не найдена
  #     - пользователь не является участником связанного чата
  deleteTodo(id: ID!): Todo!

  # обновление дела
  updateTodo(id: ID!, input: UpdateTodoInput!): Todo!

  # # Обновление полей текущего пользователя
  # ## Возвращает
  # Сущность текущего пользователя
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*:
  #     - ~~UserWithSamePhoneExists: существует пользователь с тем же телефоном~~
  #     - UserWithSameEmailExists: существует пользователь с тем же email-адресом
  updateMe(
    # обновляемые поля текущего пользователя
    input: UpdateUserInput!
  ): ActiveUser!

  # # Регистрация пользователя
  # После регистрации для текущей сессии создается активный пользователь 'ActiveUser'
  # далее все действия происходят от имени этого пользователя
  # ## Возвращает
  # Сущность текущего пользователя
  # ## Доступ
  # Только регистрирующийся пользователь, находящийся на шаге PROFILE_FILLING
  # ## Ошибки
  # - *401 Unauthorized*, сессия не находится в состоянии регистрации
  # - *403 Forbidden*:
  #     - регистрация не находится на шаге PROFILE_FILLING
  #     - UserWithSamePhoneExists: существует пользователь с тем же телефоном
  #     - UserWithSameEmailExists: существует пользователь с тем же email-адресом
  registerUser(
    # поля вновь создаваемого профиля
    input: RegisterUserInput!

    # идентификатор аватара
    avatar_id: ID
  ): ActiveUser!

  # # Получение пользователей по записям из телефонной книги
  # Клиент отправляет список телефонных номеров из книги,
  # в ответ сервер возвращает список зарегистрированных пользователей
  # с пометкой о наличии контакта
  # ## Возвращает
  # Список зарегистрированных пользователей
  # ## Доступ
  # Любой аутентифицированный, активный пользователь
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  makePosibleContacts(
    # список номеров телефонной книги
    phones: [String!]!

    # двухбуквенный код страны (любой кейс)
    countryCode: String
  ): MakePosibleContactsConnection!

  # # Добавить пуш-токен
  # Для получения пуш-нотификаций, клиент должен передать
  # сервису пуш-токен, полученный из firebase. О способах
  # получения пуш-токена можно прочесть в
  # (документации к FCM)[https://firebase.google.com/docs/cloud-messaging/]
  # ## Возвращает
  # null
  # ## Доступ
  # Любой аутентифицированный пользователь
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован
  addPushToken(
    # значение пуш-токена
    token: String!
  ): Boolean

  # # Выход из сервиса
  # Отзывает пуш-токен, установленный в текущей сессии (привязан к токену)
  # ## Возвращает
  # null
  # ## Доступ
  # Любой аутентифицированный пользователь
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован
  logout: Boolean

  # # Создание напоминания
  # ## Возвращает
  # Вновь созданное напоминание
  # ## Доступ
  # Если напоминание ассоциируется с задачей,
  # пользователь должен быть активным участником задачи.
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*:
  #     - чат не найден
  #     - пользователь не активный участник чата
  #     - идентификатор уже существует в системе
  newReminder(
    # поля вновь создаваемого напоминания
    input: NewReminderInput!
  ): Reminder!

  # # Обновление напоминания
  # ## Возвращает
  # Обновленное напоминание
  # ## Доступ
  # Только создатель может обновить напоминание
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*:
  #     - пользователь не является владельцем оповещения
  #     - чат, с которым ассоциируется оповещение, не найден
  #     - пользователь не является активным участником, ассоциируемого чата
  # - *404 Not Found*:
  #     - напоминание не найдено
  updateReminder(
    # идентификатор оповещения
    id: ID!

    # изменяемые поля оповещения
    input: UpdateReminderInput!
  ): Reminder!

  # # Отметить напоминание
  # При наступлении времени оповещения напоминание
  # должно быть отображено пользователю. Данный момент фиксирует
  # факт получения напоминания пользователем.
  # ## Возвращает
  # Отмеченное напоминание
  # ## Доступ
  # Только получатель напоминание может отметить напоминание
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*:
  #     - TODO: пользователь не является участником оповещения
  # - *404 Not Found*:
  #     - TODO: напоминание не найдено
  checkReminder(
    # идентификатор оповещения
    id: ID!
  ): Reminder!

  # # Удаление напоминаний
  # ## Возвращает
  # Идентификаторы удаленных напоминаний
  # ## Доступ
  # Только создатель напоминания может удалить напоминание
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *404 Not Found*:
  #     - напоминание не найдено
  #     - пользователь не является создателем напоминания
  deleteReminders(
    # идентификатор напоминания
    ids: [ID!]!
  ): [ID!]!

  # # Добавление пользователя в напоминание
  # ## Возвращает
  # Добавленную грань пользователь/напоминание
  # ## Доступ
  # Только создатель напоминания может добавлять пользователей в напоминение
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*, текущий пользователь не является создателем
  # - *404 Not Found*:
  #     - напоминание не найдено
  #     - добавляемый пользователь не найден
  addUserToReminder(reminder_id: ID!, user_id: ID!): ReminderMember!

  # # Удаление пользователя из напоминания
  # ## Возвращает
  # Удаленная грань пользователь/напоминание
  # ## Доступ
  # Только создатель напоминания может произвести данное действие
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*:
  #     - reminder.checked != true
  #     - текущий пользователь не является создателем
  #     - текущий пользователь удаляет себя из напоминания
  # - *404 Not Found*:
  #     - напоминание не найдено
  #     - удаляемый пользователь не найден
  removeUserFromReminder(
    reminder_id: ID!
    user_id: ID!
  ): RemoveUserFromReminderResult!

  # # Выход из напоминаний
  # ## Доступ
  # Только обычный участник напоминания (не создатель) может произвести данное действие
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*:
  #     - текущий пользователь является создателем (должен удалить напоминание)
  #     - текущий пользователь не является участником напоминания
  removeSelfFromReminders(reminder_ids: [ID!]!): Null

  # # Явное добавление пользователя в контакты
  # Пользователь, после добавления в контакты, будет возвращаться
  # в списке пользователей при запросе ` query { users { ... }} `.
  # Эффект не симметричен.
  # ## Возвращает
  # Пользователя, добавленного в контакты
  # ## Доступ
  # Любой аутентифицированный, активный пользователь
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*, попытка добавить пользователя в контакты дважды
  # - *404 Not Found*, добавляемый в контакты пользователь не найден
  addContact(user_id: ID!): User!

  # # Явное удаление пользователя из контактов
  # Пользователь, после удаления из контактов, будет возвращаться
  # в списке пользователей при запросе ` query { users { ... }} `.
  # Эффект не симметричен.
  # ## Доступ
  # Любой аутентифицированный, активный пользователь
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *404 Not Found*, удаляумый из контактов пользователь не найден
  removeContact(user_id: ID!): Null

  # # Создание отзыва
  # Рекомендацию можно оставить как для активного, так и для
  # приглашенного пользователя
  # ## Ошибки
  # - *400 ValidationError*, переданы не корректные данные
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*, попытка оставить отзыв собственному пользователю
  # - *403 Forbidden*, попытка повторного создания отзыва
  # - *404 NotFoundError*, пользователь для отзыва не найден
  createReview(user_id: ID!, input: CreateReviewInput!): Review!

  # # Обновление отзыва
  # ## Ошибки
  # - *400 ValidationError*, переданы не корректные данные
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*, попытка обновить отзыв, оставленый другим пользователем
  # - *404 NotFoundError*, отзыв не найден
  updateReview(id: ID!, input: UpdateReviewInput!): Review!

  # # Удаление отзыва
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*, попытка удалить отзыв, оставленый другим пользователем
  # - *404 NotFoundError*, отзыв не найден
  deleteReview(id: ID!): Null

  # # Первый шаг приглашения пользователя
  # Происходит проверка на наличие приглашаемого пользователя в системе.
  #
  # ## Если пользователь в системе существует
  # Возвращается сущность существующего пользователя
  # Клиент должен отобразить профиль найденого пользователя.
  #
  # ## Если пользователь в системе не существует
  # Клиент должен перейти ко второму шагу приглашения пользователя (мутация inviteAct).
  inviteRequest(
    # телефон приглашаемого пользователя
    phone: PhoneNumber!
  ): InviteRequestResult!

  # # Второй шаг приглашения пользователя
  # Создается приглашенный пользователь, ему отправляется смс-приглашение
  # и опционально добавляется отзыв.
  #
  # ## Если пользователь уже существует
  # Пользователю добавляется отзыв.
  #
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  # - *403 Forbidden*, пользователь уже приглашен.
  inviteAct(
    # телефон приглашаемого пользователя
    phone: PhoneNumber!

    # отзыв
    review: CreateReviewInput
  ): InviteActResult!

  # # Переприглашение пользователя
  # Приглашаемому пользователю отправляется смс-приглашение.
  inviteRetry(
    # идентификатор пользователя
    user_id: ID!
  ): Void!
}

type Subscription {
  # # Чат создан
  # ## Возвращает
  # Вновь созданный чат
  # Вновь созданную задачу (при наличии)
  # Вновь созданное сервисное сообщение
  # ## Доступ
  # Доставляется всем участникам вновь созданного чата
  # ## Мутации, генерирующие данное событие
  # - newChat
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  fChatCreated: CreateChatResult!

  # # В чат добавлен пользователь
  # ## Возвращает
  # Новую грань пользователь/чат
  # Вновь созданное нотификационное сообщение
  # ## Доступ
  # Доставляется всем *активным* участникам соответствующего чата
  # ## Мутации, генерирующие данное событие
  # - addUserToChat
  # - returnToChat
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  fUserAddedToChat(me_is_subject: Boolean): AddUserToChatResult!

  # # Чат создан
  # ## Возвращает
  # Вновь созданный чат
  # ## Доступ
  # Доставляется всем участникам вновь созданного чата
  # ## Мутации, генерирующие данное событие
  # - newPrivateChat
  # - newChat
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  chatCreated: IChat!
    @deprecated(reason: "используйте pmChatActivated и groupChatCreated")

  # # В личный чат было создано сообщение
  # ## Возвращает
  # Активированный личный чат
  # ## Доступ
  # Доставляется всем чата
  # ## Мутации, генерирующие данное событие
  # - newMessages
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  privateChatActivated: PrivateChat!

  # # Создан групповой чат
  # ## Возвращает
  # Вновь созанный групповой чат чат
  # ## Доступ
  # Доставляется всем чата
  # ## Мутации, генерирующие данное событие
  # - newChat
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  groupChatCreated: Chat!

  # # Чат обновлен
  # Оповещает об обновлении чата. Если при обновлении задачи
  # было установлено поле notification_disabled_till,
  # оповещение также срабатывает при наступлении указанного срока.
  # ## Возвращает
  # Обновленный чат
  # ## Доступ
  # Доставляется всем участникам вновь созданного чата
  # ## Мутации, генерирующие данное событие
  # - updateChat
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  chatUpdated: IChat!

  # # Чат удален
  # Оповещает об удалении чата.
  # ## Возвращает
  # Идентификатор удаленного чата
  # ## Доступ
  # Доставляется всем участникам удаленного чата
  # ## Мутации, генерирующие данное событие
  # - deleteChat
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  chatDeleted: ID!

  # # Обновлена статуса доставки сообщений
  # ## Возвращает
  # Статус доставки
  # ## Доступ
  # Доставляется всем *активным* участникам соответствующего чата
  # ## Мутации, генерирующие данное событие
  # - moveBookmark
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  checkStatusUpdated: CheckStatus!

  # # Из чата удален пользователь
  # ## Возвращает
  # Грань пользователь/чат
  # ## Доступ
  # Доставляется всем *активным* участникам соответствующего чата
  # ## Мутации, генерирующие данное событие
  # - removeUserFromChat
  # - leaveFromChat
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  userRemovedFromChat: ChatMember!

  # # В чат установлен черновик
  # ## Возвращает
  # Черновик и идентификатор соответствующего чата
  # ## Доступ
  # Доставляется всем клиентам пользователя, установивщего черновик
  # ## Мутации, генерирующие данное событие
  # - setDraft
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  draftSet: DraftSetResult

  # # Файл удален
  # ## Возвращает
  # Удаленный файл
  # ## Доступ
  # После удаления файла все клиенты, загрузившего пользователя
  # ## Мутации, генерирующие данное событие
  # - deleteFile
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  fileDeleted: ID!

  # # Обновлено изображение чата
  # ## Возвращает
  # Загруженное изображение чата
  # ## Доступ
  # Все участники задачи в любом статусе
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  chatImageUploaded: ChatImageUploadedResult!

  # # Файл прикреплен к чату
  # ## Возвращает
  # Прикрепленный файл
  # ## Доступ
  # После прикрепления файла к чату оповещает все клиенты, загрузившего пользователя
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  fileAttached: AttachedFile!

  # # Обновлен аватар (ваш или вашего контакта)
  # ## Возвращает
  # Обновленный аватар
  # ## Доступ
  # После успешной загрузке аватара оповещает всех пользователей, имеющих
  # общий чат, либо общее напоимнание либо явно находящегося в контактах у
  # получателя сабскрипшна.
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  userImageUploaded: UserImageUploadedResult!

  # # Обновлен аватар на этапе регистрации
  # ## Возвращает
  # Обновленный аватар
  # ## Доступ
  # Поле доступно только для пользователей на этапе регистрации
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не находится на этапе регистрации
  registeringUserImageUploaded: RegisteringUserImageUploadedResult!

  # # Колонка создана
  # ## Возвращает
  # Вновь созданную группу
  # ## Доступ
  # Доставляется всем клиентам, пользователя создавшего колонку
  # ## Мутации, генерирующие данное событие
  # - newGroup
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  groupCreated: Group!

  # # Колонка обновлена
  # ## Возвращает
  # Вновь обновленную группу
  # ## Доступ
  # Доставляется всем клиентам, пользователя - создателя колонки
  # ## Мутации, генерирующие данное событие
  # - updateGroup
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  groupUpdated: Group!

  # # Колонка удалена
  # ## Возвращает
  # Идентификатор удаленной колонки
  # ## Доступ
  # Доставляется всем клиентам, пользователя - создателя колонки
  # ## Мутации, генерирующие данное событие
  # - deleteGroup
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  groupDeleted: ID!

  # # Задача обновлена
  # ## Возвращает
  # Вновь созданную задачу
  # ## Доступ
  # Доставляется всем участникам чата, связанного с задачей
  # ## Мутации, генерирующие данное событие
  # - updateIssue
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  issueUpdated: Issue!

  # # url обработан
  # Событие инициализируется запросом необработанной ссылки,
  # а также при создании сообщения, содержащего ссылки.
  # ## Возвращает
  # Метаданные url
  # ## Доступ
  # Доставляется всем *активным* участникам чата, в которое было опубликовано
  # сообщение, содержащее ссылку.
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  urlScraped: LinkInfo!

  # # Сообщения созданы
  # ## Возвращает
  # Вновь созданное сообщение
  # ## Доступ
  # Доставляется всем *активным* участникам чата, в которое публикуется сообщение
  # ## Мутации, генерирующие данное событие
  # - newMessage
  # - множество мутаций по созданию и изменению сущностей генерирующих сервимные сообщения
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  messagesCreated: IChatMessageConnection!

  # # Сообщениe создано
  # ## Возвращает
  # Вновь созданное сообщение
  # ## Доступ
  # Доставляется всем *активным* участникам чата, в которое публикуется сообщение
  # ## Мутации, генерирующие данное событие
  # - newMessage
  # - множество мутаций по созданию и изменению сущностей генерирующих сервимные сообщения
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  messageCreated: IChatMessageEdge!
    @deprecated(reason: "используйте Subscription.messagesCreated")

  # # Сообщение обновлено
  # ## Возвращает
  # Обнавленное сообщение
  # ## Доступ
  # Доставляется всем участникам чата, имеющим доступ к обновленному сообщению
  # ## Мутации, генерирующие данное событие
  # - updateRegularMessage
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  messageUpdated: IMessage!

  # # Сообщения удалены
  # ## Возвращает
  # Идентификатор удаленных сообщений
  # ## Доступ
  # Доставляется всем участникам чата, имеющим доступ к удаленному сообщению
  # ## Мутации, генерирующие данное событие
  # - deleteMessages
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  messagesDeleted: [ID!]!

  # # Пользователь перешел в статус "онлайн"
  # ## Возвращает
  # Соответствующего пользователя
  # ## Доступ
  # Доставляется всем смежным пользователям
  # ## Мутации, генерирующие данное событие
  # - setClientStatus
  # - также безусловно генерируется при аутентификации, если статус изменился
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  userOnline: OnlineChangeResult!

  # # Пользователь перешел в статус "офлайн"
  # ## Возвращает
  # Соответствующего пользователя
  # ## Доступ
  # Доставляется всем смежным пользователям
  # ## Мутации, генерирующие данное событие
  # - setClientStatus
  # - также безусловно генерируется при аутентификации, если статус изменился
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  userOffline: OnlineChangeResult!

  # # Участник чата набирает текст
  # Если chat_id передан, то оповещение происходит только для
  # явно переданного чата, иначе для всех чатов, в которых
  # участвует пользователь.
  # ## Возвращает
  # Грань пользователь/чат
  # ## Доступ
  # Доставляется всем активным участникам чата
  # ## Мутации, генерирующие данное событие
  # - typing
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  typing(
    # идентификатор чата
    chat_id: ID
  ): ActiveChatMember!

  # # Тег создана
  # ## Возвращает
  # Вновь созданную группу
  # ## Доступ
  # Доставляется всем клиентам, пользователя создавшего тег
  # ## Мутации, генерирующие данное событие
  # - newTag
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  tagCreated: Tag!

  # # Тег обновлен
  # ## Возвращает
  # Вновь обновленную группу
  # ## Доступ
  # Доставляется всем клиентам, пользователя - создателя тег
  # ## Мутации, генерирующие данное событие
  # - updateTag
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  tagUpdated: Tag!

  # # Тег удален
  # ## Возвращает
  # Идентификатор удаленного тега
  # ## Доступ
  # Доставляется всем клиентам, пользователя - создателя тега
  # ## Мутации, генерирующие данное событие
  # - deleteTag
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  tagDeleted: ID!

  # # У задачи установлены теги
  # ## Возвращает
  # Задачу
  # ## Доступ
  # Доставляется всем клиентам, пользователя, установившего теги
  # ## Мутации, генерирующие данное событие
  # - setIssueTags
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  issueTagsSetted: Issue!

  # # Дело создано
  # ## Возвращает
  # Вновь созданное дело
  # ## Доступ
  # Доставляется всем участникам чата, связанного с делом
  # ## Мутации, генерирующие данное событие
  # - newTodo
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  todoCreated: Todo!

  # # Дело удалено
  # ## Возвращает
  # Удаленное дело
  # ## Доступ
  # Доставляется всем участникам чата, связанного с делом
  # ## Мутации, генерирующие данное событие
  # - deleteTodo
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  todoDeleted: Todo!

  # # Дело обновлено
  # ## Возвращает
  # Обновленное дело
  # ## Доступ
  # Доставляется всем участникам чата, связанного с делом
  # ## Мутации, генерирующие данное событие
  # - updateTodo
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  todoUpdated: Todo!

  # # Пользователь обновлен
  # ## Возвращает
  # Обновленный пользователь
  # ## Доступ
  # Доставляется всем [смежным пользователям](https://gudexco.atlassian.net/wiki/spaces/PD/pages/294913)
  # ## Мутации, генерирующие данное событие
  # - updateMe
  # - verifyPhone
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  userUpdated: ActiveUser!

  # # Создано напоминание
  # ## Возвращает
  # Вновь созданное напоминание
  # ## Доступ
  # Доставляется всем участникам напоминания
  # ## Мутации, генерирующие данное событие
  # - newReminder
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  reminderCreated: Reminder!

  # # Напоминание обновлено
  # ## Возвращает
  # Обновленное напоминание
  # ## Доступ
  # Доставляется всем участникам напоминания
  # ## Мутации, генерирующие данное событие
  # - updateReminder
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  reminderUpdated: Reminder!

  # # Напоминание активировано
  # ## Возвращает
  # Напоминание, срок которого подошел
  # ## Доступ
  # Доставляется всем участникам напоминания
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  reminderActivated: Reminder!

  # # Напоминания удалены
  # ## Возвращает
  # Идентификаторы удаленных напоминаний
  # ## Доступ
  # Доставляется всем участникам напоминания
  # ## Мутации, генерирующие данное событие
  # - deleteReminders
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  remindersDeleted: [ID!]!

  # # В напоминание добавлен пользователь
  # ## Возвращает
  # Грань пользователь/напоминание
  # ## Доступ
  # Доставляется всем участникам, соответствующего напоминания
  # ## Мутации, генерирующие данное событие
  # - addUserToReminder
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  userAddedToReminder: ReminderMember!

  # # Из напоминания удален пользователь
  # ## Возвращает
  # Грань пользователь/напоминание
  # ## Доступ
  # Доставляется всем участникам, соответствующего напоминания
  # ## Мутации, генерирующие данное событие
  # - removeUserFromReminder
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  userRemovedFromReminder: RemoveUserFromReminderResult!

  # # Пользователи добавлены в контакты
  # ## Возвращает
  # Список пользователей, добавленных в контакты
  # ## Доступ
  # Доставляется всем клиентам, добавившего
  # ## Мутации, генерирующие данное событие
  # - addContact
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  contactsAdded: [User!]!

  # # Пользователь удалён из контактов
  # ## Возвращает
  # Идентификатор пользователя, удаленный из контактов
  # ## Доступ
  # Доставляется всем клиентам, удалившего
  # ## Мутации, генерирующие данное событие
  # - removeContact
  # ## Ошибки
  # - *401 Unauthorized*, пользователь не аутентифицирован или не активен
  contactRemoved: ID!
}

# The DateTime scalar type represents date time strings complying to ISO-8601.
scalar DateTime

# E.164 phone format (without +)
scalar PhoneNumber

# The Email scalar type represents E-Mail addresses compliant to RFC 822.
scalar Email

# The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar JSON

# Bookmark value
scalar Bookmark

# Always null
scalar Null

# field for sorting (https://github.com/truongkhanhduy95/Lexorank)
scalar LexoRank

# The `LongInt` scalar type represents non-fractional signed whole numeric values. LongInt can represent values between -(2^53 - 1) and 2^53 - 1.
scalar LongInt

type Void {
  _: Boolean
}

# Информация о пагинации в коннекшне
type PageInfo {
  # Существует ли еще следующая страница?
  hasNextPage: Boolean!

  # Существует ли предыдущая страница?
  hasPreviousPage: Boolean!

  # Первый курсор на странице. Может использоваться для получения предыдущей страницы
  startCursor: String

  # Последний курсор на странице. Может использоваться для получения следующей страницы
  endCursor: String

  # Первый курсор со следующей страницы
  nextPageStartCursor: String

  # Последний курсор с предыдущей страницы
  prevPageEndCursor: String
}

# Грань пользователь/чат
type ChatMember {
  # чат
  chat: IChat!

  # пользователь
  user: User!
}

# Грань активный пользователь/чат
type ActiveChatMember {
  # чат
  chat: IChat!

  # пользователь
  user: ActiveUser!
}

# Коннекшн чат/сообщения
type IChatMessageConnection {
  pageInfo: PageInfo!
  edges: [IChatMessageEdge!]!
}

# Грань чат/сообщение
type IChatMessageEdge {
  node: IMessage!
  cursor: String!

  # букмарк, используется для учета прочтенности доставленности
  # см. CheckStatus
  # для bookmark гарантируется лексикографическая отсортированность
  bookmark: Bookmark!
}

# Грань чат/нотфикационное сообщение
type IChatNootificationMessageEdge {
  node: NotificationMessage!
  cursor: String!

  # букмарк, используется для учета прочтенности доставленности
  # см. CheckStatus
  # для bookmark гарантируется лексикографическая отсортированность
  bookmark: Bookmark!
}

# Коннекшн напоминание/пользователь
type ReminderUserConnection {
  pageInfo: PageInfo!
  edges: [ReminderUserEdge!]!
}

# Грань напоминание/сообщение
type ReminderUserEdge {
  node: User!
  cursor: String!
}

# Коннекшн чат/пересланное сообщения
type ChatForwardMessageConnection {
  pageInfo: PageInfo!
  edges: [ChatFrowardMessageEdge!]!
}

# Грань чат/пересланное сообщение
type ChatFrowardMessageEdge {
  node: ForwardMessage!
  cursor: String!

  # букмарк, используется для учета прочтенности доставленности
  # см. CheckStatus
  # для bookmark гарантируется лексикографическая отсортированность
  bookmark: Bookmark!
}

# Интерфейс чата
interface IChat {
  id: ID!

  # статус прочтенности/доставленности
  check_status: CheckStatus!

  # сохраненный черновик. интерпертировать пустую строку как отсутствие черновика
  draft: String!

  # дата создания чата
  created_at: DateTime!

  # чат скрыт
  hidden: Boolean

  # индекс сортировки *поле индивидуально для пользователя*
  rank: LexoRank

  # *[несобственное поле](https://gudexco.atlassian.net/wiki/spaces/PD/pages/294913)*  Уровень назойливости событий чата
  notification: ChatNotificationState!

  # *[несобственное поле](https://gudexco.atlassian.net/wiki/spaces/PD/pages/294913)*  Ограничить состояние notification датой, например - отлючить звук до...
  # Если устанавливаетсу notification_disabled_till,
  # то при наступлении указанного времени,
  # состояние notification снова возвращается в ON.
  # При наступлении указанного времени,
  # придет сабскрипшн chatUpdated,
  # где будет notification = 'ON', notification_disabled_till = null .
  notification_disabled_till: DateTime

  # файлы, прикрепленные к данному чату, но еще не отправленные
  attached_files(
    after: String
    first: Int
    before: String
    last: Int
  ): AttachedFileConnection!
    @deprecated(
      reason: "от данного механизма в продукте отказались, ждем решения по новому видению"
    )

  # избранные сообщения данного чата
  favorite_messages(
    after: String
    first: Int
    before: String
    last: Int
  ): ChatFavoriteMessagesConnection!

  # файлы, прикрепленные к сообщениям данного чата
  files(
    filter: ChatFilesFilterInput
    after: String
    before: String
    around: ID
    first: Int
    last: Int
  ): MessageFileConnection!

  # ссылки в сообщениях
  links(
    after: String
    first: Int
    before: String
    last: Int
  ): LinkInfoConnection!

  # сообщения чата
  messages(
    after: String
    before: String
    around: ID
    around_bookmark: Bookmark
    first: Int
    last: Int
  ): IChatMessageConnection!

  # дела, прикрепленные к чату
  todos(after: String, first: Int, before: String, last: Int): TodoConnection!

  # пользователи в чате
  users(
    # фильтр по стейту участника, по умолчанию - только активные
    state_filter: ChatUsersStateFilter
  ): IChatUserConnection!
}

# Чат
type Chat implements IChat {
  id: ID!

  # статус прочтенности/доставленности
  check_status: CheckStatus!

  # сохраненный черновик. интерпертировать пустую строку как отсутствие черновика
  draft: String!

  # дата создания чата
  created_at: DateTime!

  # чат скрыт
  hidden: Boolean

  # индекс сортировки *поле индивидуально для пользователя*
  rank: LexoRank

  # *[несобственное поле](https://gudexco.atlassian.net/wiki/spaces/PD/pages/294913)*  Уровень назойливости событий чата
  notification: ChatNotificationState!

  # *[несобственное поле](https://gudexco.atlassian.net/wiki/spaces/PD/pages/294913)*  Ограничить состояние notification датой, например - отлючить звук до...
  # Если устанавливаетсу notification_disabled_till,
  # то при наступлении указанного времени,
  # состояние notification снова возвращается в ON.
  # При наступлении указанного времени,
  # придет сабскрипшн chatUpdated,
  # где будет notification = 'ON', notification_disabled_till = null .
  notification_disabled_till: DateTime

  # состояние чата
  state: ChatState!

  # описание чата
  caption: String!

  # заголовок чата
  title: String!

  # файлы, прикрепленные к данному чату, но еще не отправленные
  attached_files(
    after: String
    first: Int
    before: String
    last: Int
  ): AttachedFileConnection!

  # избранные сообщения данного чата
  favorite_messages(
    after: String
    first: Int
    before: String
    last: Int
  ): ChatFavoriteMessagesConnection!

  # файлы, прикрепленные к сообщениям данного чата
  files(
    filter: ChatFilesFilterInput
    after: String
    before: String
    around: ID
    first: Int
    last: Int
  ): MessageFileConnection!

  # ссылки в сообщениях
  links(
    after: String
    first: Int
    before: String
    last: Int
  ): LinkInfoConnection!

  # сообщения чата
  messages(
    after: String
    before: String
    around: ID
    around_bookmark: Bookmark
    first: Int
    last: Int
  ): IChatMessageConnection!

  # дела, прикрепленные к чату
  todos(after: String, first: Int, before: String, last: Int): TodoConnection!

  # пользователи в чате
  users(
    # фильтр по стейту участника, по умолчанию - только активные
    state_filter: ChatUsersStateFilter
  ): IChatUserConnection!

  # изображение чата
  image: ChatImage

  # задача, свзанная с данным чатом
  issue: Issue

  # пользователь-создатель чата
  creator: RegisteredUser!
}

# Приватный чат (личка)
type PrivateChat implements IChat {
  id: ID!

  # статус прочтенности/доставленности
  check_status: CheckStatus!

  # сохраненный черновик. интерпертировать пустую строку как отсутствие черновика
  draft: String!

  # дата создания чата
  created_at: DateTime!

  # файлы, прикрепленные к данному чату, но еще не отправленные
  attached_files(
    after: String
    first: Int
    before: String
    last: Int
  ): AttachedFileConnection!

  # избранные сообщения данного чата
  favorite_messages(
    after: String
    first: Int
    before: String
    last: Int
  ): ChatFavoriteMessagesConnection!

  # файлы, прикрепленные к сообщениям данного чата
  files(
    filter: ChatFilesFilterInput
    after: String
    before: String
    around: ID
    first: Int
    last: Int
  ): MessageFileConnection!

  # ссылки в сообщениях
  links(
    after: String
    first: Int
    before: String
    last: Int
  ): LinkInfoConnection!

  # сообщения чата
  messages(
    after: String
    before: String
    around: ID
    around_bookmark: Bookmark
    first: Int
    last: Int
  ): IChatMessageConnection!

  # дела, прикрепленные к чату
  todos(after: String, first: Int, before: String, last: Int): TodoConnection!

  # пользователи в чате
  users(
    # фильтр по стейту участника, по умолчанию - только активные
    state_filter: ChatUsersStateFilter
  ): IChatUserConnection!

  # второй пользователь переговорки
  another_user: User!

  # чат скрыт
  hidden: Boolean

  # индекс сортировки *поле индивидуально для пользователя*
  rank: LexoRank

  # *[несобственное поле](https://gudexco.atlassian.net/wiki/spaces/PD/pages/294913)*  Уровень назойливости событий чата
  notification: ChatNotificationState!

  # *[несобственное поле](https://gudexco.atlassian.net/wiki/spaces/PD/pages/294913)*  Ограничить состояние notification датой, например - отлючить звук до...
  # Если устанавливаетсу notification_disabled_till,
  # то при наступлении указанного времени,
  # состояние notification снова возвращается в ON.
  # При наступлении указанного времени,
  # придет сабскрипшн chatUpdated,
  # где будет notification = 'ON', notification_disabled_till = null .
  notification_disabled_till: DateTime
}

# Интерфейс сообщений
interface IMessage {
  id: ID!
  timestamp: DateTime!

  # глобальный порядок сообщения 53-bits, сравнивая данные числа легко определить в каком порядке они были созданы аналог twitter snowflake
  order: LongInt!

  # Флаг того, что сообщение в избранных.
  # Гарантируется, что будет установлено в запросе сообщений чата,
  # в остальных случаях не гарантируется.
  is_favorite: Boolean

  # флаг того, что сообщение отправил текущий пользователь
  is_my: Boolean!

  # чат, в который отправили сообщение, может быть null в процитированных сообщениях
  chat: IChat!

  # пользователь, отправивший сообщение
  user: RegisteredUser!

  # идентификаторы пользователей, прочитавших сообщение
  viewed_by: [ID!]!
}

# сообщение-файл
type FileMessage implements IMessage {
  id: ID!
  timestamp: DateTime!

  # глобальный порядок сообщения 53-bits, сравнивая данные числа легко определить в каком порядке они были созданы аналог twitter snowflake
  order: LongInt!

  # Флаг того, что сообщение в избранных.
  # Гарантируется, что будет установлено в запросе сообщений чата,
  # в остальных случаях не гарантируется.
  is_favorite: Boolean

  # флаг того, что сообщение отправил текущий пользователь
  is_my: Boolean!

  # чат, в который отправили сообщение, может быть null в процитированных сообщениях
  chat: IChat!

  # пользователь, отправивший сообщение
  user: RegisteredUser!

  # идентификаторы пользователей, прочитавших сообщение
  viewed_by: [ID!]!

  # файлы, прикрепленные к данной задаче, но еще не отправленные
  file: MessageFile!
  quoted_message: QuotedMessage
}

# обычное сообщение
type RegularMessage implements IMessage {
  id: ID!
  timestamp: DateTime!

  # глобальный порядок сообщения 53-bits, сравнивая данные числа легко определить в каком порядке они были созданы аналог twitter snowflake
  order: LongInt!

  # Флаг того, что сообщение в избранных.
  # Гарантируется, что будет установлено в запросе сообщений чата,
  # в остальных случаях не гарантируется.
  is_favorite: Boolean

  # флаг того, что сообщение отправил текущий пользователь
  is_my: Boolean!

  # флаг того, что сообщение было отредактировано
  edited: Boolean!

  # чат, в который отправили сообщение, может быть null в процитированных сообщениях
  chat: IChat!

  # пользователь, отправивший сообщение
  user: RegisteredUser!

  # идентификаторы пользователей, прочитавших сообщение
  viewed_by: [ID!]!

  # информация о ссылках в данном сообщении
  links: [LinkInfo!]!

  # текст сообщения
  message: String!
  quoted_message: QuotedMessage

  # Пользователи, упомянутые в сообщении.
  # Сейчас - возвращаются все упомянутые пользователи,
  # в дальнейшем будут возвращаться только пользователи,
  # не являющиеся участниками чата
  mentioned_users: UserConnection!
}

# сообщение-уведомление
type NotificationMessage implements IMessage {
  id: ID!
  timestamp: DateTime!

  # глобальный порядок сообщения 53-bits, сравнивая данные числа легко определить в каком порядке они были созданы аналог twitter snowflake
  order: LongInt!

  # Флаг того, что сообщение в избранных.
  # Гарантируется, что будет установлено в запросе сообщений чата,
  # в остальных случаях не гарантируется.
  is_favorite: Boolean

  # флаг того, что сообщение отправил текущий пользователь
  is_my: Boolean!

  # чат, в который отправили сообщение, может быть null в процитированных сообщениях
  chat: IChat!

  # пользователь, отправивший сообщение
  user: RegisteredUser!

  # идентификаторы пользователей, прочитавших сообщение
  viewed_by: [ID!]!

  # данные для формирования сообщения
  data: [NotificationDSL!]!
}

# пересланное сообщение
type ForwardMessage implements IMessage {
  id: ID!
  timestamp: DateTime!

  # глобальный порядок сообщения 53-bits, сравнивая данные числа легко определить в каком порядке они были созданы аналог twitter snowflake
  order: LongInt!

  # Флаг того, что сообщение в избранных.
  # Гарантируется, что будет установлено в запросе сообщений чата,
  # в остальных случаях не гарантируется.
  is_favorite: Boolean

  # флаг того, что сообщение отправил текущий пользователь
  is_my: Boolean!

  # чат, в который отправили сообщение, может быть null в процитированных сообщениях
  chat: IChat!

  # пользователь, отправивший сообщение
  user: RegisteredUser!

  # идентификаторы пользователей, прочитавших сообщение
  viewed_by: [ID!]!

  # пересланное сообщение
  forwarded_message: ForwardedMessage!
}

interface IFile {
  # id файла
  id: ID!

  # ключ на s3
  key: String!

  # дата загрузки файла
  timestamp: DateTime!

  # url оригинала
  url: String!

  # размер файла
  content_length: LongInt!

  # mime-тип
  content_type: String!
}

# Изображение чата
type ChatImage implements IFile {
  # выбранная пользователем зона изображения
  area: ImageArea

  # id файла
  id: ID!

  # ключ на s3
  key: String!

  # дата загрузки файла
  timestamp: DateTime!

  # url оригинала
  url: String!

  # размер файла
  content_length: LongInt!

  # mime-тип
  content_type: String!
}

# Аватар пользователя
type UserImage implements IFile {
  # id файла
  id: ID!

  # выбранная пользователем зона изображения
  area: ImageArea

  # ключ на s3
  key: String!

  # дата загрузки файла
  timestamp: DateTime!

  # url оригинала
  url: String!

  # размер файла
  content_length: LongInt!

  # mime-тип
  content_type: String!
}

# Прикрепленый файл
type AttachedFile implements IFile {
  # чат, к которому прикреплен файл
  attached_to: IChat!

  # тип файла
  type: FileType!

  # id файла
  id: ID!

  # ключ на s3
  key: String!

  # дата загрузки файла
  timestamp: DateTime!

  # url оригинала
  url: String!

  # размер файла
  content_length: LongInt!

  # mime-тип
  content_type: String!

  # имя файла
  file_name: String!
}

# Файл отправленый сообщением
type MessageFile implements IFile {
  # сообщение, к которому прикреплен файл
  message: FileMessage!

  # тип файла
  type: FileType!

  # id файла
  id: ID!

  # ключ на s3
  key: String!

  # дата загрузки файла
  timestamp: DateTime!

  # url оригинала
  url: String!

  # размер файла
  content_length: LongInt!

  # mime-тип
  content_type: String!

  # имя файла
  file_name: String!
}

# метаданные ссылки
type LinkInfo {
  message: IMessage

  # Флаг ошибки скраппинга
  error: Boolean!

  # Флаг выполнения скрапинга в данный момент (жди в сабскрипшне)
  pending: Boolean!

  # A human-readable representation of the author's name.
  author: String

  # An representation of the date the article was published.
  date: DateTime

  # The publisher's chosen description of the article.
  description: String

  # An image URL that best represents the article.
  image: String

  # An ISO 639-1 representation of the url content language.
  lang: String

  # An image URL that best represents the publisher brand.
  logo: String

  # A human-readable representation of the publisher's name.
  publisher: String

  # The publisher's chosen title of the article.
  title: String

  # The URL of the article.
  url: String!

  # A video URL that best represents the article.
  video: String
}

# Задача
type Issue {
  id: ID!

  # дата создания задачи
  created_at: DateTime!

  # дата завершения
  end_date: DateTime

  # дата начала
  start_date: DateTime!

  # чат
  chat: Chat!

  # исполнитель
  executor: User

  # колонка
  group: Group!

  # индекс сортировки *поле индивидуально для пользователя*
  # для закрытой задачи может быть равен z
  rank: LexoRank!
  tags: TagConnection!
}

# Подзадача
type Todo {
  id: ID!

  # описание задачи
  caption: String!

  # название задачи
  title: String!

  # индекс сортировки
  rank: LexoRank!

  # состаяние задачи
  state: TodoState!

  # дата создания задачи
  created_at: DateTime!

  # дата завершения
  end_date: DateTime

  # дата начала
  start_date: DateTime!

  # чат
  chat: IChat!
}

# Напоминание
type Reminder {
  id: ID!

  # флаг получения оповещения для текущего пользователя
  checked: Boolean!

  # авторизованный пользователь - создатель напоминания
  is_my: Boolean!

  # время срабатывания напоминания
  timestamp: DateTime!

  # название напоминания
  title: String!

  # пользователь-создатель напоминания
  creator: RegisteredUser!

  # пользователи в чате
  users: ReminderUserConnection!

  # дата создания напоминания
  created_at: DateTime!
}

# Колонка задач
type Group {
  id: ID!

  # заголовок группы
  title: String!

  # индекс сортировки
  rank: LexoRank!
  state: GroupState
}

# Тэг задачи
type Tag {
  id: ID!
  title: String!
  color: Int!
  issues: IssueConnection!
}

type IMessageConnection {
  pageInfo: PageInfo!
  edges: [IMessageEdge!]!
}

type IMessageEdge {
  node: IMessage!
  cursor: String!
}

type ChatFavoriteMessagesConnection {
  pageInfo: PageInfo!
  edges: [IMessageEdge!]!

  # # Количество избранных сообщений
  count: Int!
}

type GroupConnection {
  pageInfo: PageInfo!
  edges: [GroupEdge!]!
}

type GroupEdge {
  node: Group!
  cursor: String!
}

type IssueConnection {
  pageInfo: PageInfo!
  edges: [IssueEdge!]!
}

type IssueEdge {
  node: Issue!
  cursor: String!
}

type LinkInfoConnection {
  pageInfo: PageInfo!
  edges: [LinkInfoEdge!]!
}

type LinkInfoEdge {
  node: LinkInfo!
  cursor: String!
}

type TagConnection {
  pageInfo: PageInfo!
  edges: [TagEdge!]!
}

type TagEdge {
  node: Tag!
  cursor: String!
}

type TodoConnection {
  pageInfo: PageInfo!
  edges: [TodoEdge!]!
}

type TodoEdge {
  node: Todo!
  cursor: String!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge!]!
}

type UserEdge {
  node: User!
  cursor: String!
}

type IChatUserConnection {
  pageInfo: PageInfo!
  edges: [IChatUserEdge!]!
}

type IChatUserEdge {
  node: User!
  cursor: String!
}

type MakeOTPResult {
  # время, до которого для данного номера запросы не принимаются
  nextBackoffTime: DateTime

  # одноразовый логин
  oneTimeLogin: String!
}

type OTPToTokenResult {
  # пользователь, под которым текущая сессия стала аутентифицирована
  me: MyUser!

  # токен аутентификации
  token: AuthToken!
}

# токен аутентификации
type AuthToken {
  # количество секунд жизни токена
  expiration: Int!

  # окончание валидности
  expiration_date: DateTime!

  # токен
  token: String!
}

type IChatConnection {
  pageInfo: PageInfo!
  edges: [IChatEdge!]!
}

type IChatEdge {
  node: IChat!
  cursor: String!
}

type AttachedFileConnection {
  pageInfo: PageInfo!
  edges: [AttachedFileEdge!]!
}

type AttachedFileEdge {
  node: AttachedFile!
  cursor: String!
}

type MessageFileConnection {
  pageInfo: PageInfo!
  edges: [MessageFileEdge!]!
}

type MessageFileEdge {
  node: MessageFile!
  cursor: String!
}

# фильтр по статусу участника чата
enum ChatUsersStateFilter {
  # только активные участники
  ACTIVE

  # все участники
  ALL
}

input ChatFilesFilterInput {
  # тип файла
  type: FileType

  # исключить по mime
  exclude_mime: [String!]

  # включить по mime
  include_mime: [String!]
}

# сущность, содержащая информацию о прочтенности сообщений
type CheckStatus {
  # чат
  chat: IChat!

  # количество непрочитанных сообщений в чате
  unread_messages_count: Int!

  # букмарк последнего сообщения, прочитанного другими пользователями
  #
  # считать прочитанными сообщение при условии strcmp(IChatMessageEdge.bookmark, last_viewed) <= 0
  last_viewed: Bookmark!

  # букмарк последнего прочитанное мною сообщение,
  # служит для отображения новых сообщений при загрузке чата
  #
  # считать прочитанными сообщение при условии strcmp(IChatMessageEdge.bookmark, my_last_viewed) <= 0
  my_last_viewed: Bookmark!

  # пользователь был упомянут после позиции букмарка
  # (был упомянут после последнего прочтеного сообщения)
  mentioned: Boolean!
}

# Фильтр по списку чатов
input ChatsFilterInput {
  # фильтровать по идентификаторам чатов
  ids: [ID!]

  # фильтровать по активности, если передан true, будут выбраны активные чаты,
  # если false, неактивные
  active: Boolean

  # фильтр по флагу скрытия
  hidden: Boolean

  # исключить личные чаты
  exclude_pm: Boolean

  # последнее сообщение создано после
  last_message_after: DateTime

  # последнее сообщение создано до
  last_message_before: DateTime
}

input NewChatInput {
  # id чата
  id: ID

  # название задачи
  title: String!

  # описание задачи
  caption: String

  # *[несобственное поле](https://gudexco.atlassian.net/wiki/spaces/PD/pages/294913)*
  # уровень назойливости событий чата,
  notification: ChatNotificationState

  # *[несобственное поле](https://gudexco.atlassian.net/wiki/spaces/PD/pages/294913)*    Ограничить состояние notification датой, например - отлючить звук до...
  # Если устанавливаетсу notification_disabled_till,
  # то при наступлении указанного времени,
  # состояние notification снова возвращается в ON.
  # При наступлении указанного времени,
  # придет сабскрипшн chatUpdated,
  # где будет notification = 'ON', notification_disabled_till = null .
  notification_disabled_till: DateTime

  # чат скрыт
  hidden: Boolean
}

input NewIssueInput {
  # id задачи
  id: ID

  # дата завершения
  end_date: DateTime

  # дата начала
  start_date: DateTime

  # id исполнителя
  executor_user_id: ID

  # id колонки
  group_id: ID

  # индекс сортировки *поле индивидуально для пользователя*
  rank: LexoRank
}

input NewPrivateChatInput {
  # id чата
  id: ID
}

input UpdateChatInput {
  # название задачи
  title: String

  # описание задачи
  caption: String

  # *[несобственное поле](https://gudexco.atlassian.net/wiki/spaces/PD/pages/294913)*
  # уровень назойливости событий чата,
  notification: ChatNotificationState

  # *[несобственное поле](https://gudexco.atlassian.net/wiki/spaces/PD/pages/294913)*    Ограничить состояние notification датой, например - отлючить звук до...
  # Если устанавливаетсу notification_disabled_till,
  # то при наступлении указанного времени,
  # состояние notification снова возвращается в ON.
  # При наступлении указанного времени,
  # придет сабскрипшн chatUpdated,
  # где будет notification = 'ON', notification_disabled_till = null .
  notification_disabled_till: DateTime

  # чат скрыт *поле индивидуально для пользователя*
  hidden: Boolean

  # индекс сортировки *поле индивидуально для пользователя*
  rank: LexoRank
}

type DraftSetResult {
  chat_id: ID!
  draft: String!
}

# Измененные сущности мутации createChat
type CreateChatResult {
  # вновь созданный чат
  createdChat: Chat!

  # вновь созданная задача
  createdIssue: Issue
}

type AddUserToChatResult {
  # созданное сервисное сообщение
  createdNotificationMessage: IChatNootificationMessageEdge!

  # вновь созданная грань пользователь/чат
  createdChatUserEdge: ChatMember!
}

# используется для сохранения данных для выбора области на изображении
type ImageArea {
  x: Int!
  y: Int!
  width: Int!
  height: Int!
}

# Подписаный запрос, содержит и необходимые поля, которые необходимо отправить
# в виде FormData.
# Также должно быть добавлено поле "file", содержащее контент загружаемого файла
type PresignedRequest {
  url: String!
  fields: [PresignedField!]!
}

type PresignedField {
  name: String!
  value: String!
}

# используется для сохранения данных для выбора области на изображении
input ImageAreaInput {
  x: Int!
  y: Int!
  width: Int!
  height: Int!
}

input PresignChatImageInput {
  # id файла
  id: ID
  chat_id: ID!
  content_type: String!
  content_length: LongInt!
  area: ImageAreaInput
}

input PresignUserImageInput {
  # id файла
  id: ID
  content_type: String!
  content_length: LongInt!
  area: ImageAreaInput
}

input PresignMessageFileInput {
  # id файла
  id: ID
  chat_id: ID!
  content_type: String!
  content_length: LongInt!
  filename: String!

  # тип файла
  type: FileType!
}

type RegisteringUserImageUploadedResult {
  # аватар
  image: UserImage!
}

type UserImageUploadedResult {
  # идентификатор пользователя, для которого загружено изображение
  user_id: ID!

  # аватар
  image: UserImage!
}

type ChatImageUploadedResult {
  # идентификатор чата, для которого загружено изображение
  chat_id: ID!

  # аватар
  image: ChatImage!
}

# статус колонки
enum GroupState {
  REGULAR
  DEFAULT
  DEFAULT_HIDDEN
}

input NewGroupInput {
  id: ID

  # заголовок группы
  title: String!

  # индекс сортировки
  rank: LexoRank
}

input UpdateGroupInput {
  # заголовок группы
  title: String

  # индекс сортировки
  rank: LexoRank
}

input IssuesFilterInput {
  # фильтровать по id
  ids: [ID!]

  # фильтровать по активности
  active: Boolean
}

# Коннекшн поиска задач
type IssueSearchConnection {
  edges: [IssueSearchEdge!]!
}

# Грань поиска задач
type IssueSearchEdge {
  node: Issue!
  by_file: MessageFile!
}

input UpdateIssueInput {
  # дата завершения
  end_date: DateTime

  # дата начала
  start_date: DateTime

  # id исполнителя
  executor_user_id: ID

  # id группы
  group_id: ID

  # индекс сортировки *поле индивидуально для пользователя*
  rank: LexoRank
}

enum SearchMessageWhere {
  ISSUE
  CHAT
  PM_CHAT
}

input SearchMessageFilter {
  where: SearchMessageWhere!
}

union QuotedMessage =
    FileMessage
  | RegularMessage
  | ForwardMessage
  | DeletedMessage

union ForwardedMessage = FileMessage | RegularMessage | DeletedMessage

interface INotificationText {
  text: String!
}

type NotificationText implements INotificationText {
  text: String!
}

type NotificationUser implements INotificationText {
  id: ID!
  text: String!
}

type NotificationTodo implements INotificationText {
  id: ID
  text: String!
}

union NotificationDSL = NotificationText | NotificationUser | NotificationTodo

type DeletedMessage {
  # поле-заглушка - graphql не допускает типы без полей
  _: Boolean
}

type SearchMessagesConnection {
  pageInfo: PageInfo!
  edges: [SearchMessagesEdge!]!

  # # Количество найденных сообщений
  count: Int!
}

type SearchMessagesEdge {
  node: RegularMessage!
  cursor: String!
}

input NewMessageInput {
  # для текстового сообщения
  text_message: NewTextMessageInput

  # для сообщения-файла
  file_message: NewFileMessageInput
}

input NewTextMessageInput {
  # id сообщения
  id: ID

  # текст сообщения
  message: String!

  # id цитируемого сообщения
  quoted_message_id: ID
}

input NewFileMessageInput {
  # id сообщения
  id: ID

  # id отправляемого файла
  file_id: ID!

  # id цитируемого сообщения
  quoted_message_id: ID
}

input UpdateMessageInput {
  # текст сообщения
  message: String!
}

# настройки
type Settings {
  # Ограничение на количество тегов, которые может создать пользователь
  maxUserTags: Int!

  # Ограничение на количество тегов, которые можно прикрепить к задаче
  maxIssueTags: Int!

  # Ограничение на количество участников чата (задачи)
  maxChatMembersCount: Int!

  # Ограничение на количество участников напоминания
  maxReminderMembersCount: Int!

  # Максимальное сообщений для пересылки
  maxForwardMessages: Int!

  # Максимальное количество чатов для пересылки сообщений
  maxForwardChats: Int!

  # Максимальное количество сообщений, которые можно удалить одновременно
  maxDeleteMessagesCount: Int!

  # Максимальный размер поля ввода, кроме размера текста сообщения
  maxFieldLength: Int!

  # Максимальный размер текста сообщения
  maxMessageLength: Int!

  # Максимальный размер черновика (chat.draft)
  maxDraftLength: Int!

  # Максимальный размер файла, загружаемого в сообщения
  maxMessageFileLength: LongInt!

  # Максимальный размер файла, загружаемого в сообщения
  maxMessageImageLength: LongInt!

  # Максимальный размер изображения чата
  maxChatImageLength: LongInt!

  # Максимальный размер изображения чата
  maxUserImageLength: LongInt!

  # Максимальное количество сообщений, которые можно отправить в секунду
  maxMessagesPerSecond: Int!

  # адрес сервиса бизнес-логики
  backendBaseUrl: String!

  # адрес фронт-енда для данного окрежения
  frontendBaseUrl: String!

  # адрес сервиса ресайза изображений
  resizeBaseUrl: String!

  # адрес сервиса веб-скрапинга
  scrapperBaseUrl: String!

  # адрес сервиса множественного скачивания файлов
  zipperBaseUrl: String!

  # рекомендованный таймаут для отправки информации о том, что пользователь набирает сообщение
  typingTimeout: Int!

  # количество секунд с создания сообщения в течение которого доступно его обновление
  messageUpdateInterval: Int!

  # количество секунд с создания сообщения в течение которого доступно его удаление
  messageDeleteInterval: Int!

  # количество секунд с создания чата, в течение которых доступно удаление
  chatDeleteInterval: Int!

  # версия сервиса бизнес-логики
  version: String

  # Максимальная длина поля описания в отзыве
  maxReviewDescriptionLength: Int!
}

type OnlineChangeResult {
  # Идентификатор пользователя изменившего статус онлайн
  id: ID!

  # время когда пользователь был последний раз онлайн
  last_seen: DateTime!

  # состояние пользователя
  online: Boolean!
}

input NewTagInput {
  id: ID
  title: String!
  color: Int!
}

input UpdateTagInput {
  title: String
  color: Int
}

input NewTodoInput {
  # id задачи
  id: ID

  # описание задачи
  caption: String

  # состаяние задачи
  state: TodoState

  # название задачи
  title: String!

  # id чата
  chat_id: ID!

  # индекс сортировки
  rank: LexoRank

  # дата завершения
  end_date: DateTime

  # дата начала
  start_date: DateTime
}

input UpdateTodoInput {
  # описание задачи
  caption: String

  # состаяние задачи
  state: TodoState

  # название задачи
  title: String

  # индекс сортировки
  rank: LexoRank

  # дата завершения
  end_date: DateTime

  # дата начала
  start_date: DateTime
}

type MakePosibleContactsConnection {
  edges: [MakePosibleContactsEdge!]!
}

type MakePosibleContactsEdge {
  # Телефон из телефонной книги
  raw_phone: String!

  # Интернационализированный номер телефона
  internationalized_phone: PhoneNumber

  # Если пользователь найден, будет представлен
  node: User

  # Пользователь в контактах у текущего
  is_contact: Boolean!
}

union MyUser = ActiveUser | RegisteringUser

union User = ActiveUser | InvitedUser

union RegisteredUser = ActiveUser

# интерфейс пользователь
interface IUser {
  id: ID!

  # Пользователь в контактах у текущего
  is_contact: Boolean!

  # отзывы, оставленные данному пользователю. null, если отзывов нет
  reviews(first: Int!, after: String): UserReviewsConnection!
}

# пользователь, находящийся в процессе регистрации
type RegisteringUser {
  # телефон пользователя
  phone: PhoneNumber!

  # шаг регистрации
  registration_step: RegistrationStep!

  # аватар пользователя
  avatar: UserImage
}

# приглашенный пользователь
type InvitedUser implements IUser {
  id: ID!

  # телефон приглашенного пользователя, отображается только пригласившему пользователю
  phone: PhoneNumber

  # Пользователь в контактах у текущего
  is_contact: Boolean!

  # отзывы, оставленные данному пользователю. null, если отзывов нет
  reviews(first: Int!, after: String): UserReviewsConnection!
}

# активный пользователь
type ActiveUser implements IUser {
  id: ID!

  # флаг того, что это текущий пользователь
  is_my: Boolean!

  # телефон
  phone: PhoneNumber

  # является ли пользователь "оператором",
  # оператору отправляются сервисные сообщения,
  # также оператор поумолчанию добавляется к пользователям в контакты
  is_operator: Boolean!

  # дата регистрации
  join_date: DateTime!

  # время когда пользователь был последний раз онлайн (окончание предыдущей сессии)
  last_seen: DateTime!

  # состояние пользователя
  online: Boolean!

  # профиль
  profile: UserProfile!

  # аватар пользователя
  avatar: UserImage

  # Пользователь в контактах у текущего
  is_contact: Boolean!

  # отзывы, оставленные данному пользователю. null, если отзывов нет
  reviews(first: Int!, after: String): UserReviewsConnection!
}

# профиль активного пользователя
type UserProfile {
  # email пользователя
  email: Email!

  # имя
  first_name: String!

  # фамилия
  last_name: String!

  # специальность
  job_title: String

  # город
  city: String

  # пол
  gender: Gender!

  # склонения
  declension: UserProfileDeclension
}

# пол пользователя
enum Gender {
  # мужчина
  MALE

  # женщина
  FEMALE

  # не определен
  ANDROGYNOUS
}

# склонения профиля пользователя
type UserProfileDeclension {
  # склонения города пользователя
  city: UserProfileCityDeclension

  # склонения имени
  first_name: Declention

  # склонения фамилии
  last_name: Declention
}

# склонения города пользователя
type UserProfileCityDeclension {
  # в Санкт-петербурге
  in: String

  # из Санкт-Петербурга
  from: String

  # в Санкт-Петербург
  to: String
}

# склонения
type Declention {
  # именительный (кто? что?)
  nominative: String

  # родительный (кого? чего?)
  genitive: String

  # дательный (кому? чему?)
  dative: String

  # винительный (кого? что?)
  accusative: String

  # творительный (кем? чем?)
  instrumental: String

  # предложный (о ком? о чем?)
  prepositional: String
}

input UserProfileUpdateInput {
  # email пользователя
  email: Email

  # имя
  first_name: String

  # фамилия
  last_name: String

  # специальность
  job_title: String

  # город
  city: String
}

input UpdateUserInput {
  # профиль пользователя
  profile: UserProfileUpdateInput!
}

input RegisterUserInput {
  # email пользователя
  email: Email!

  # имя
  first_name: String!

  # фамилия
  last_name: String!

  # специальность
  job_title: String

  # город
  city: String
}

type ReminderConnection {
  pageInfo: PageInfo!
  edges: [ReminderEdge!]!
}

type ReminderEdge {
  node: Reminder!
  cursor: String!
}

# Грань пользователь/оповещение
type ReminderMember {
  # напоминание
  reminder: Reminder!

  # пользователь
  user: User!
}

# Результат удалениея пользователя из напоминания
type RemoveUserFromReminderResult {
  # ID напоминания
  reminder_id: ID!

  # ID пользователя
  user_id: ID!
}

# Фильтр по списку напоминаний
input ReminderFilterInput {
  # фильтровать по флагу оповещения, если передан true, будут выбраны чекнутые напоминания,
  # если false, нечекнуты
  checked: Boolean
}

input NewReminderInput {
  # id напоминания
  id: ID

  # время срабатывания напоминания
  timestamp: DateTime!

  # название задачи
  title: String!
}

input UpdateReminderInput {
  # название задачи
  title: String

  # время срабатывания напоминания
  timestamp: DateTime
}

type ContactUsersConnection {
  pageInfo: PageInfo!
  edges: [ContactUsersEdge!]!
}

type ContactUsersEdge {
  node: User!
  cursor: String!
}

type RootUserConnection {
  edges: [RootUserEdge!]!
}

type RootUserEdge {
  # Пользователь в контактах у текущего
  is_contact: Boolean!
  node: User!
}

# Grade value
scalar Grade

type MeanGradesDetail {
  quality: Float!
  communication: Float!
  price: Float!
}

type Grades {
  quality: Grade!
  communication: Grade!
  price: Grade!
}

# Рекомендация
type Review {
  id: ID!

  # Название оказаной услуги
  title: String!

  # Текст отзыва
  description: String!

  # Время создания
  timestamp: DateTime!

  # Средняя оценка отзыва
  mean_grade: Float!

  # Оценки детально
  grades: Grades!

  # Пользователь, оставивший отзыв
  reviewer: ActiveUser!
  user: IUser!
}

type UsersWithReviewConnection {
  pageInfo: PageInfo!
  edges: [UsersWithReviewEdge!]!
}

type UsersWithReviewEdge {
  node: IUser!
  cursor: String!
}

type UserReviewsConnection {
  pageInfo: PageInfo!
  edges: [UserReviewsEdge!]!

  # Средняя оценка серди всех отзывов
  mean_grade: Float

  # Средние оценки по категория
  mean_grades_detail: MeanGradesDetail

  # Общее количество отзывов
  count: Int!

  # Пользователь имеет отзыв от текущего пользователя
  my_review: Review
}

type UserReviewsEdge {
  node: Review!
  cursor: String!
}

input GradesInput {
  quality: Grade!
  communication: Grade!
  price: Grade!
}

input CreateReviewInput {
  id: ID
  title: String!
  description: String
  grades: GradesInput!
}

input UpdateReviewInput {
  title: String
  description: String
  grades: GradesInput
}

type InviteRequestResult {
  existing_user: User
}

type InviteActResult {
  invited_user: InvitedUser!
}
